================================================================================
UNREAL ENGINE BULLET HELL GAME - COMPLETE STEP-BY-STEP TUTORIAL
================================================================================

This tutorial recreates the Unity "magisterka_1" bullet-hell shooter in Unreal Engine 5.
The game features:
- Player ship with movement and shooting
- Enemies that move downward with sinusoidal horizontal motion
- Enemy spawning that increases over time
- Radial bullet patterns from enemies
- Score, lives, and timer UI
- Special "bomb" ability to clear screen
- 5-minute game duration with victory/defeat conditions

================================================================================
PART 1: PROJECT SETUP
================================================================================

STEP 1.1: Create New Project
--------------------------------------------------------------------------------
1. Open Epic Games Launcher
2. Click "Unreal Engine" tab on the left sidebar
3. Click yellow "Launch" button next to your UE5 version
4. Wait for Unreal Engine to open (this may take 1-2 minutes)

5. In the "Unreal Project Browser" window that appears:
   - At the top, select "Games" category (should be selected by default)
   - Click "Blank" template (empty square icon)
   
6. On the right side panel, configure:
   - Project Defaults: Blueprint (not C++)
   - Target Platform: Desktop
   - Quality Preset: Maximum
   - Starter Content: UNCHECKED (we don't need it)
   - Raytracing: UNCHECKED

7. At the bottom:
   - Choose folder location where you want to save
   - Name the project: "BulletHellGame"
   
8. Click "Create" button (bottom right, yellow)

EXPECTED RESULT: Unreal Editor opens with an empty level. You should see:
- Main 3D viewport in the center
- Outliner panel on the right (showing "Untitled" level)
- Details panel on the right side

NOTE: The Content Drawer is NOT open by default. To open it:
- Click "Content Drawer" button at the bottom of the screen, OR
- Press Ctrl+Space, OR
- Go to Window → Content Drawer


STEP 1.2: Set Up 2D Game View
--------------------------------------------------------------------------------
Since bullet-hell games are typically 2D, we'll set up a top-down orthographic view.

1. In the main viewport, look at the top-left corner
2. Click the dropdown that says "Perspective"
3. Select "Top" from the dropdown menu (alt + J)

4. To set up proper camera for the game:
   - Go to menu bar (the top bar): Edit (Second from left, next fo "File" and "Window") → Project Settings
   - In the left sidebar, search for "Maps & Modes" (Project -> 4th from the top, next to GameplayTags and Movies)
   - Click on "Maps & Modes"
   
5. Under "Default Modes":
   - Find "Default GameMode" dropdown
   - We'll create our own later, leave it for now

6. Close Project Settings window (X in top right)


STEP 1.3: Create Folder Structure
--------------------------------------------------------------------------------
1. Look at the Content Browser at the bottom of the screen
2. You should see "Content" folder on the left panel

3. Right-click on "Content" folder → New Folder
   Name it: "Blueprints"

4. Right-click on "Content" folder → New Folder
   Name it: "Materials"

5. Right-click on "Content" folder → New Folder
   Name it: "Sprites" (for 2D textures)

6. Right-click on "Content" folder → New Folder
   Name it: "UI"

EXPECTED RESULT: Content Browser shows 4 folders:
   Content/
   ├── Blueprints/
   ├── Materials/
   ├── Sprites/
   └── UI/


================================================================================
PART 2: CREATE THE PLAYER
================================================================================

STEP 2.1: Create Player Blueprint
--------------------------------------------------------------------------------
1. In Content Browser, double-click "Blueprints" folder to open it

2. Right-click in empty space → Blueprint Class

3. In the popup window "Pick Parent Class":
   - Click "Pawn" (NOT Character - we want simple 2D control)
   - Click "Select"

4. Name the new Blueprint: "BP_Player"

5. Double-click "BP_Player" to open the Blueprint Editor

EXPECTED RESULT: A new tab opens showing the Blueprint Editor with:
- Components panel on the left
- Viewport in the center
- Details panel on the right
- Tab bar above the Viewport with: Viewport | Construction Script | Event Graph (third from left)


STEP 2.2: Add Player Visual Components
--------------------------------------------------------------------------------
1. In the Components panel (left side), you'll see "DefaultSceneRoot"
   - Click on "DefaultSceneRoot" to select it (this ensures new components are added as children)

2. With DefaultSceneRoot selected, click "Add" button (green, top of Components panel)
   - Search for "Paper Sprite"
   - Click "Paper Sprite" to add it (it will be added as a child of DefaultSceneRoot)
   - Rename it to "PlayerSprite" (click on it, then press F2)

   NOTE: If Paper Sprite is not available:
   - Go to Edit → Plugins (from main menu bar)
   - Search for "Paper2D"
   - Make sure "Paper2D" plugin is ENABLED
   - Restart the editor if prompted

3. With "PlayerSprite" selected, look at Details panel (right side):
   - Find "Source Sprite" property
   - For now, leave it empty (we'll create sprites later)
   - Under "Transform", set Scale to (1.0, 1.0, 1.0)

4. With DefaultSceneRoot still selected, click "Add" button again:
   - Search for "Box Collision"
   - Click "Box Collision" to add it (it will be added as a child of DefaultSceneRoot)
   - Rename it to "PlayerCollision"

5. With "PlayerCollision" selected, in Details panel:
   - Under "Shape", set Box Extent to: X=25, Y=25, Z=10
   - Under "Collision", click "Collision Presets" dropdown
   - Select "Custom..."
   - Set "Collision Enabled" to "Query Only (No Physics Collision)"
   - Enable "Generate Overlap Events" box

6. With DefaultSceneRoot still selected, click "Add" button:
   - Search for "Arrow"
   - Click "Arrow" to add it (it will be added as a child of DefaultSceneRoot)
   - This shows which direction is "forward" (useful for debugging)

7. With DefaultSceneRoot still selected, click "Add" button:
   - Search for "Cube" → add "Cube" (Static Mesh)
   - Rename it to "TempVisual"
   - In Details panel, set Scale to (0.5, 0.5, 0.1) so it's small and flat
   - This provides a visible placeholder until we add proper sprites in Part 9

8. With DefaultSceneRoot still selected, click "Add" button:
   - Search for "Camera" → add "Camera"
   - Rename it to "PlayerCamera"
   - In Details panel, set Location to: X=0, Y=0, Z=1000 (1000 units above player)
   - Set Rotation to: X=0, Y=-90, Z=0 (looking straight down)
   - In Details panel, find "Activation" category → "Auto Activate" checkbox
     - This should already be ENABLED by default
     - If not, check/enable it - this tells Unreal to use THIS camera when playing
   - This camera will follow the player, making testing easy
   
   NOTE: This temporary camera ensures you can see the player during testing.
   In Part 8, we'll set up a proper fixed camera for the final game.

EXPECTED RESULT: Components panel shows:
   DefaultSceneRoot
   ├── PlayerSprite (Paper Sprite)
   ├── PlayerCollision (Box Collision)
   ├── Arrow
   ├── TempVisual (Cube)
   └── PlayerCamera (Camera)

9. IMPORTANT - Enable Auto Possession for testing:
   - Click on "BP_Player (Self)" at the top of the Components panel (the root)
   - In Details panel, find "Pawn" category
   - Find "Auto Possess Player" dropdown (currently set to "Disabled")
   - Change it to "Player 0"
   - This makes the engine automatically possess this pawn when playing,
     which activates the PlayerCamera
   
   NOTE: This setting will be overridden later when we set up the GameMode
   in Part 8, which handles possession automatically.


STEP 2.3: Create Player Variables
--------------------------------------------------------------------------------
(Continue in the same BP_Player Blueprint Editor tab that was opened in Step 2.1)

1. In the Blueprint Editor, look at the left panel (below the Components panel)
2. Find "My Blueprint" section
3. Under "Variables", click the "+" button

4. Create these variables one by one (click +, then set properties in Details):

   NOTE: Variables are NOT added to the Components hierarchy. They appear in a 
   separate "Variables" list within the "My Blueprint" panel. Variables store 
   data values, while Components are physical/visual parts of the actor.

   Variable 1:
   - Name: "MoveSpeed"
   - Type: Float (click dropdown next to variable, select Float)
   - Click "eye" icon to make it public/editable
   - Compile the blueprint (Click on "Compile" third option from left or cimply Ctrl + Alt)
   - In Details panel, set Default Value: 750.0 
   
   Variable 2:
   - Name: "BoundsMin"
   - Type: Vector 2D (search for "Vector 2D" in type dropdown)
   - Default Value: X=-850, Y=-450
   
   Variable 3:
   - Name: "BoundsMax"
   - Type: Vector 2D
   - Default Value: X=850, Y=450
   
   Variable 4:
   - Name: "FireInterval"
   - Type: Float
   - Default Value: 0.08
   
   Variable 5:
   - Name: "FireTimer"
   - Type: Float
   - Default Value: 0.0
   
   Variable 6:
   - Name: "BulletSpeed"
   - Type: Float
   - Default Value: 2200.0
   
   Variable 7:
   - Name: "MaxLives"
   - Type: Integer
   - Default Value: 3
   
   Variable 8:
   - Name: "CurrentLives"
   - Type: Integer
   - Default Value: 3
   
   Variable 9:
   - Name: "VolleySize"
   - Type: Integer
   - Default Value: 3
   
   Variable 10:
   - Name: "VolleySpread"
   - Type: Float
   - Default Value: 12.0
   
   Variable 11:
   - Name: "SpecialUsed"
   - Type: Boolean
   - Default Value: false (unchecked)
   
   Variable 12:
   - Name: "BulletClass"
   - Type: In the type dropdown, go to "Object Types" category → "Actor" → 
     select "Class Reference" (the subcategory under Actor)
   - This will hold reference to bullet blueprint class for spawning

5. Click "Compile" button (top left, blue checkmark icon)
6. Click "Save" button (floppy disk icon next to Compile)

EXPECTED RESULT: My Blueprint panel shows:
- All 12 variables you created listed under "Variables"
- A "Components" category with 4 component references (DefaultSceneRoot, 
  PlayerSprite, PlayerCollision, Arrow) - these are automatically created 
  from the components you added in Step 2.2


STEP 2.4: Set Up Enhanced Input System
--------------------------------------------------------------------------------
UE5 uses the Enhanced Input System. Before creating movement logic in our 
Blueprint, we first need to create Input Actions and an Input Mapping Context.

0. ENABLE ENHANCED INPUT IN PROJECT SETTINGS (CRITICAL):

   Before creating any input assets, you MUST configure the project to use
   Enhanced Input as the default input system:
   
   1. Go to Edit → Project Settings
   2. In the left sidebar, scroll down to "Engine" section
   3. Click on "Input"
   4. Find "Default Classes" section (near the top)
   5. Set "Default Player Input Class" to: EnhancedPlayerInput
   6. Set "Default Input Component Class" to: EnhancedInputComponent
   7. Close Project Settings
   
   WARNING: If you skip this step, WASD controls will NOT work even if
   everything else is set up correctly!

1. SET UP INPUT ASSETS (in Content Drawer):

   A) CREATE INPUT ACTIONS:
   
   1. Open Content Drawer (Ctrl+Space or click "Content Drawer" at bottom)
   2. In Content folder, right-click → New Folder → name it "Input"
   
   3. Inside Input folder, right-click → Input → Input Action
      - Name it "IA_Move"
      - Double-click to open
      - Set "Value Type" to "Axis2D (Vector2D)"
      - Save and close
   
   4. Create another Input Action: "IA_Fire"
      - Set "Value Type" to "Digital (bool)" (default)
   
   5. Create another Input Action: "IA_Special"
      - Set "Value Type" to "Digital (bool)"

   B) CREATE INPUT MAPPING CONTEXT:
   
   1. In Input folder, right-click → Input → Input Mapping Context
      - Name it "IMC_Default"
      - Double-click to open
   
   2. Click "+" next to "Mappings" to add IA_Move:
      - Select "IA_Move" from dropdown
      - Click "+" under IA_Move to add key bindings:
      
      For W key (move up/forward):
        - Click "+", select "W"
        - Under W, click "+" next to "Modifiers"
        - Add "Swizzle Input Axis Values" → set Order to "YXZ"
        
      For S key (move down/backward):
        - Click "+", select "S"
        - Add Modifier: "Swizzle Input Axis Values" → Order: "YXZ"
        - Add Modifier: "Negate"
        
      For A key (move left):
        - Click "+", select "A"
        - Add Modifier: "Negate"
        
      For D key (move right):
        - Click "+", select "D"
        - No modifiers needed
   
   3. Click "+" to add IA_Fire:
      - Select "IA_Fire"
      - Add key: "Z"
      - Add key: "Left Mouse Button"
   
   4. Click "+" to add IA_Special:
      - Select "IA_Special"
      - Add key: "X"
      - Add key: "Right Mouse Button"
   
   5. Save the Input Mapping Context

2. NOW OPEN BP_PLAYER BLUEPRINT:

   1. In Content Drawer, navigate to Content → Blueprints
   2. Double-click "BP_Player" to open the Blueprint Editor
   3. Click on "Event Graph" tab (above the main view, third tab from left, 
      next to Construction Script)

   You should see three default events (red nodes):
   - Event BeginPlay
   - Event ActorBeginOverlap  
   - Event Tick

3. ADD MAPPING CONTEXT IN BEGINPLAY:
   
   From "Event BeginPlay" node:
   
   1. Right-click → search "Get Player Controller" → add it
   2. From the output, drag and search "Get Enhanced Input Local Player Subsystem"
   3. From that output, drag and search "Add Mapping Context"
   4. For "Mapping Context" input: 
      - Click dropdown and select "IMC_Default"
      - Or drag IMC_Default from Content Drawer
   5. Set "Priority" to 0
   
   6. CRITICAL - Connect the execution wire (white wire):
      - Drag from the WHITE pin on the right side of "Event BeginPlay"
      - Connect it to the WHITE pin on the left side of "Add Mapping Context"
      - Without this execution wire, the mapping context is NEVER added!

   VERIFY: You should have a white wire going:
   Event BeginPlay (white pin) ──────► Add Mapping Context (white pin)

4. SIMPLE MOVEMENT TEST (verify input works before building full logic):

   Before creating the complex movement network, let's verify input is working:
   
   a) From "Event Tick" node, drag from the WHITE execution pin
   b) Search "Print String" → add it
   c) For the "In String" input, we'll connect the input value:
      - Right-click → search "Get Player Controller" → add it
      - From Player Controller, drag → "Get Enhanced Input Local Player Subsystem"
      - From subsystem, drag → search "IA_Move" (under Input → Enhanced Action Values)
      - Right-click on the IA_Move output → "To Text (Vector2D)" or just drag to Print String
   
   d) Compile and Save
   e) Drag BP_Player into level, Press Play
   f) Press WASD keys and look at top-left of screen
   
   EXPECTED: You should see numbers changing when you press WASD:
   - W: Y value goes positive (like "X=0.0 Y=1.0")
   - S: Y value goes negative
   - A: X value goes negative  
   - D: X value goes positive
   
   IF YOU SEE "X=0.0 Y=0.0" ALWAYS (no change when pressing WASD):
   - Check that IMC_Default has the WASD keys mapped correctly
   - Check that Event BeginPlay execution wire connects to Add Mapping Context
   - Check Project Settings → Input → Default Classes are set to Enhanced versions
   
   IF THIS TEST WORKS: Delete the Print String node and continue to step 5.
   IF THIS TEST FAILS: Fix the input setup before proceeding.

5. MOVEMENT LOGIC - Create this node network:

   From "Event Tick" node:
   
   a) Right-click → search "Get Player Controller" and add it
   
   b) From Player Controller output, right-click → "Get Enhanced Input Local Player Subsystem"
   
   c) From subsystem output, drag and right-click → search "IA_Move"
      - Look under "Input" → "Enhanced Action Values" → select "IA_Move"
      - This node returns the current value of the IA_Move input action
   
   d) The output is an Input Action Value (Vector2D since we set IA_Move to Axis2D).
      Right-click the output pin → "Split Struct Pin" to get X and Y components,
      OR drag from output and search "To Vector 2D" to convert it

   e) Right-click → "Make Vector"
      - Connect the X from movement input to X
      - Connect the Y from movement input to Y  
      - Set Z to 0
      
   f) Right-click → "Normalize"
      - Connect the vector output to Normalize input
      
   g) Right-click → "Get World Delta Seconds"
   
   h) Right-click → "Get MoveSpeed" (your variable)
   
   i) Right-click → Multiply (float * float)
      - Connect Delta Seconds output to first input
      - Connect MoveSpeed output to second input
      
   j) Right-click → Multiply (vector * float)
      - Connect Normalized vector (from step f) to vector input
      - Connect (DeltaSeconds * MoveSpeed) result (from step i) to float input
      - This output is the "movement delta" - how far to move this frame
      
   k) Right-click → "Get Actor Location"
   
   l) Right-click → Add (vector + vector)
      - Connect current location (from step k) to first input
      - Connect movement delta (from step j) to second input
      
   m) CLAMP X COORDINATE:
      First, break apart the new position vector from step l:
      - Right-click on the output pin of the Add node (from step l) → "Split Struct Pin"
      - This splits the vector into three separate pins: X, Y, Z
      
      Now clamp the X value:
      - Right-click in empty space → search "Clamp (float)" → add it
      - Connect the "X" output (from the split Add node) to "Value" input of Clamp
      
      Get the min bound:
      - Right-click → search "Get BoundsMin" (your variable) → add it
      - Right-click on BoundsMin output pin → "Split Struct Pin" (splits into X, Y)
      - Connect BoundsMin's "X" to Clamp's "Min" input
      
      Get the max bound:
      - Right-click → search "Get BoundsMax" (your variable) → add it
      - Right-click on BoundsMax output pin → "Split Struct Pin"
      - Connect BoundsMax's "X" to Clamp's "Max" input
      
      The Clamp node now outputs the X position clamped within bounds.
      
   n) CLAMP Y COORDINATE:
      - Right-click → add another "Clamp (float)" node
      - Connect the "Y" output (from the split Add node in step m) to "Value"
      - Connect BoundsMin's "Y" (already split) to "Min"
      - Connect BoundsMax's "Y" (already split) to "Max"
   
   o) Right-click → "Make Vector"
      - Connect clamped X
      - Connect clamped Y
      - Set Z to 0
      
   p) Right-click → "Set Actor Location"
      - Connect the clamped vector to "New Location"
      
   q) CRITICAL - Connect the execution wire (white wire):
      - Drag from the WHITE pin on the right side of "Event Tick"
      - Connect it to the WHITE pin on the left side of "Set Actor Location"
      - Without this execution wire, the movement code NEVER runs!
      
      VERIFY: You should have a white wire going:
      Event Tick (white pin) ──────► Set Actor Location (white pin)

6. Click Compile and Save

EXPECTED RESULT after Compile:
- Compile button shows GREEN checkmark (no errors)
- No warnings about unconnected pins

HOW TO TEST AT THIS STAGE:
1. Open any level (or the default "Untitled" level)
2. From Content Drawer, drag BP_Player into the viewport
3. Press Play (Alt+P)
4. You should see the cube (TempVisual added in Step 2.2) and control it with WASD

EXPECTED RESULT when tested:
- Player pawn moves smoothly when pressing WASD keys
- Movement is frame-rate independent (consistent speed)
- Player cannot move outside the screen bounds (stops at edges)
- Releasing keys immediately stops movement (no drift)

NOTE: Full game testing will be possible after completing Part 8 (Level Setup).


VISUAL DIAGRAM OF MOVEMENT NODES:
┌─────────────┐
│ Event Tick  │──────────────────────────────────────────────►
└─────────────┘                                               │
       │                                                      │
       ▼                                                      ▼
┌──────────────────────────────────┐                 ┌────────────────────┐
│ Get Enhanced Input Subsystem     │                 │ Set Actor Location │
│ → Get Action Value (IA_Move)     │                 └────────────────────┘
│ → Get as Vector2D                │                          ▲
└────────────────┬─────────────────┘                          │
                 │                                    ┌───────────────┐
                 ▼                                    │ Clamped Vector│
    ┌────────────────────────────┐                    └───────────────┘
    │      Make Vector           │───►Normalize───►          ▲
    │  X=Input.X, Y=Input.Y, Z=0 │   (direction)             │
    └────────────────────────────┘        │           ┌─────────────┐
                                          ▼           │ + Location  │
                                    ┌──────────────┐  └─────────────┘
                                    │ * MoveSpeed  │─────────┘
                                    │ * DeltaTime  │
                                    └──────────────┘


STEP 2.5: Create Player Firing Logic
--------------------------------------------------------------------------------
1. Continue in Event Graph, we'll add firing after movement

2. After the movement logic, add firing check using Enhanced Input:

   a) Right-click → search "Enhanced Input Action" 
      - Select "EnhancedInputAction IA_Fire"
      - This creates an event node that fires when the action is triggered
   
   b) From the "Triggered" execution pin:
      - Get FireTimer variable
      - Subtract Delta Seconds from it
      - Branch: if FireTimer <= 0:
        - Reset FireTimer to FireInterval
        - Call "FireVolley" function (we'll create this)
   
   NOTE: Since IA_Fire was set up with Z key and Left Mouse Button in the 
   Input Mapping Context, both inputs will trigger this action automatically.

3. CREATE FIRE VOLLEY FUNCTION:
   
   a) In "My Blueprint" panel, under "Functions", click "+"
   b) Name the function "FireVolley"
   c) Double-click to open function graph
   
   d) Inside FireVolley function:
   
      - Get VolleySize variable
      - Branch: if VolleySize == 1, fire single bullet straight up
      - Else: loop from 0 to VolleySize-1
        - Calculate angle: StartAngle + (i * VolleySpread)
        - StartAngle = -(VolleySpread * (VolleySize-1)) / 2
        - Create direction vector from angle
        - Spawn bullet at player location with that direction

4. CREATE SPAWN BULLET FUNCTION:

   a) Add new function "SpawnBullet"
   
   b) Add input parameters (click + on function entry):
      - SpawnLocation (Vector)
      - Direction (Vector)
   
   c) Inside function:
      - Right-click → "Spawn Actor from Class"
      - Connect BulletClass variable to "Class" input
      - Connect SpawnLocation to "Spawn Transform Location"
      
   d) After spawning:
      - Cast the return value to BP_Bullet (we'll create this later)
      - Call "Initialize" function on the bullet
      - Pass Direction and BulletSpeed, IsEnemy=false

5. Compile and Save

EXPECTED RESULT after Compile:
- Compile button shows GREEN checkmark
- "FireVolley" and "SpawnBullet" functions appear under Functions in My Blueprint panel

EXPECTED RESULT in Play mode:
- NOTE: Bullets won't spawn yet because BP_Bullet doesn't exist
- After BP_Bullet is created (Part 3), pressing Z or Left Mouse Button will:
  - Spawn 3 bullets in a spread pattern (VolleySize=3)
  - Bullets travel upward from player position
  - Rapid fire when holding the button (every 0.08 seconds)


STEP 2.6: Create Player Damage and Special Ability
--------------------------------------------------------------------------------
1. CREATE "TakeHit" FUNCTION:

   a) Add new function "TakeHit"
   b) Add input parameter: Damage (Integer)
   
   c) Inside:
      - Get CurrentLives
      - Subtract Damage
      - Clamp to minimum 0
      - Set CurrentLives
      - If CurrentLives <= 0:
        - Call HandleDeath function

2. CREATE "HandleDeath" FUNCTION:

   a) Add new function "HandleDeath"
   
   b) Inside:
      - Get reference to GameDirector (we'll create later)
      - Call "HandlePlayerDeath" on GameDirector
      - Set Actor Hidden in Game = true
      - Disable Input

3. SPECIAL ABILITY (Screen Clear):

   Using Enhanced Input (IA_Special was already set up with X and Right Mouse):

   a) Right-click → search "EnhancedInputAction IA_Special"
      - This creates an event node that fires when X or Right Mouse is pressed
   
   b) From the "Triggered" execution pin:
      - Get SpecialUsed variable
      - Branch: if SpecialUsed is false:
        - Set SpecialUsed = true
        - Call "ClearAllEnemies" (global function)
        - Call "ClearAllEnemyBullets" (global function)

4. Compile and Save

EXPECTED RESULT after Compile:
- Compile button shows GREEN checkmark
- "TakeHit" and "HandleDeath" functions appear under Functions
- Event Graph shows special ability logic connected to Event Tick

EXPECTED RESULT in Play mode (after all parts are complete):
- When enemy bullet hits player: Lives decrease by 1
- When Lives reach 0: Player disappears, game shows "Game Over"
- Pressing X or Right Mouse Button (once per game):
  - All enemies on screen are destroyed
  - All enemy bullets are destroyed
  - Second press does nothing (SpecialUsed = true)


================================================================================
PART 3: CREATE THE BULLET
================================================================================

STEP 3.1: Create Bullet Blueprint
--------------------------------------------------------------------------------
1. In Content Browser → Blueprints folder
2. Right-click → Blueprint Class → Actor
3. Name it: "BP_Bullet"
4. Double-click to open

5. Add Components:
   - Paper Sprite → name "BulletSprite"
   - Sphere Collision → name "BulletCollision"
     - Radius: 8
     - Generate Overlap Events: CHECKED
     - Collision Preset: Custom → Query Only
   - Cube (Static Mesh) → name "TempVisual"
     - Scale: (0.1, 0.1, 0.05) - small bullet-sized cube
     - This provides visibility until proper visuals in Part 9

6. Create Variables:
   - TravelDirection (Vector) - Default: (0, 1, 0)
   - TravelSpeed (Float) - Default: 1200.0
   - RemainingLifetime (Float) - Default: 4.0
   - IsEnemyProjectile (Boolean) - Default: false
   - Damage (Integer) - Default: 1

EXPECTED RESULT after Compile:
- Compile button shows GREEN checkmark
- Components panel shows: DefaultSceneRoot → BulletSprite, BulletCollision, TempVisual
- Variables panel shows all 5 variables with correct types

EXPECTED RESULT in Viewport (Blueprint Editor):
- Small cube visible (the TempVisual placeholder)
- Sphere collision visible (radius 8)


STEP 3.2: Bullet Movement Logic
--------------------------------------------------------------------------------
1. In Event Graph, from Event Tick:

   a) Calculate movement:
      - Get TravelDirection
      - Multiply by TravelSpeed
      - Multiply by Delta Seconds
      - Add to current location
      - Set Actor Location
   
   b) Check lifetime:
      - Subtract Delta Seconds from RemainingLifetime
      - If <= 0: Destroy Actor

2. CREATE "Initialize" FUNCTION:
   
   a) Add input parameters:
      - Direction (Vector)
      - Speed (Float)
      - bIsEnemy (Boolean)
      - Lifetime (Float)
      - DamageValue (Integer) - default 1
   
   b) Inside:
      - Normalize Direction → Set TravelDirection
      - Set TravelSpeed = Speed
      - Set IsEnemyProjectile = bIsEnemy
      - Set RemainingLifetime = Lifetime
      - Set Damage = DamageValue

3. Compile and Save

EXPECTED RESULT after Compile:
- Compile button shows GREEN checkmark
- "Initialize" function appears under Functions with 5 input parameters

EXPECTED RESULT in Play mode (when spawned by player):
- Bullets move in their assigned direction at TravelSpeed
- Bullets automatically destroy after RemainingLifetime seconds (default 4s)
- Movement is smooth and frame-rate independent


STEP 3.3: Bullet Collision Logic
--------------------------------------------------------------------------------
1. Click on "BulletCollision" component in Components panel

2. In Details panel, scroll to "Events" section
   - Click "+" next to "On Component Begin Overlap"
   - This creates event node in Event Graph

3. In the Event Graph, from "On Component Begin Overlap":

   a) First, check if this is enemy projectile:
      - Get IsEnemyProjectile
      - Branch
      
   b) IF IS ENEMY PROJECTILE (True branch):
      - Get Other Actor from the overlap event
      - Cast to BP_Player
      - If cast succeeds:
        - Call TakeHit on player, passing Damage
        - Destroy this bullet (Destroy Actor)
        
   c) IF IS PLAYER BULLET (False branch):
      - Get Other Actor
      - Cast to BP_Enemy
      - If cast succeeds:
        - Call ApplyDamage on enemy, passing Damage
        - Destroy this bullet

4. Compile and Save

EXPECTED RESULT after Compile:
- Compile button shows GREEN checkmark
- Event Graph shows "On Component Begin Overlap" event connected to Branch

EXPECTED RESULT in Play mode:
- Player bullets (IsEnemyProjectile=false) hitting enemies:
  - Enemy takes damage, bullet disappears
- Enemy bullets (IsEnemyProjectile=true) hitting player:
  - Player takes hit, bullet disappears
- Bullets passing through other objects: No effect (bullets ignore non-targets)


================================================================================
PART 4: CREATE THE ENEMY
================================================================================

STEP 4.1: Create Enemy Blueprint
--------------------------------------------------------------------------------
1. Content Browser → Blueprints
2. Right-click → Blueprint Class → Actor
3. Name: "BP_Enemy"
4. Double-click to open

5. Add Components:
   - Paper Sprite → "EnemySprite"
   - Box Collision → "EnemyCollision"
     - Box Extent: X=30, Y=30, Z=10
     - Generate Overlap Events: CHECKED
   - Cube (Static Mesh) → name "TempVisual"
     - Scale: (0.6, 0.6, 0.1) - larger than player cube
     - This provides visibility until proper visuals in Part 9

6. Create Variables:
   - MaxHealth (Integer) - Default: 12
   - CurrentHealth (Integer) - Default: 12
   - ScoreValue (Integer) - Default: 50
   - VerticalSpeed (Float) - Default: 220.0
   - HorizontalAmplitude (Float) - Default: 250.0
   - HorizontalFrequency (Float) - Default: 1.8
   - DespawnY (Float) - Default: -750.0
   - FireInterval (Float) - Default: 0.35
   - BulletsPerBurst (Integer) - Default: 20
   - BurstSpread (Float) - Default: 360.0
   - EnemyBulletSpeed (Float) - Default: 1000.0
   - EnemyBulletLifetime (Float) - Default: 6.0
   - BaseX (Float) - Default: 0.0
   - WaveSeed (Float) - Default: 0.0
   - FireTimer (Float) - Default: 0.0
   - BulletClass (Class Reference to Actor)

EXPECTED RESULT after Compile:
- Compile button shows GREEN checkmark
- Components panel shows: DefaultSceneRoot → EnemySprite, EnemyCollision, TempVisual
- Variables panel shows all 16 variables with correct types and defaults

EXPECTED RESULT in Viewport (Blueprint Editor):
- Cube visible (the TempVisual placeholder, larger than player)
- Box collision visible (30x30x10)


STEP 4.2: Enemy Initialization
--------------------------------------------------------------------------------
1. In Event Graph, from "Event BeginPlay":

   a) Set CurrentHealth = MaxHealth
   
   b) Get Actor Location → Break Vector → Set BaseX = X value
   
   c) Random Float in Range (0, 6.28) → Set WaveSeed
      (6.28 ≈ 2π for wave randomization)
   
   d) Random Float in Range (0, FireInterval) → Set FireTimer

EXPECTED RESULT after Compile:
- Compile button shows GREEN checkmark
- BeginPlay event connected to variable setters

EXPECTED RESULT in Play mode:
- Each enemy spawns with randomized WaveSeed (0 to 6.28)
- Each enemy starts with different FireTimer offset
- This creates varied, non-synchronized enemy behavior


STEP 4.3: Enemy Movement Logic
--------------------------------------------------------------------------------
1. In Event Graph, from "Event Tick":

   a) VERTICAL MOVEMENT:
      - Get Actor Location → Break into X, Y, Z
      - Subtract (VerticalSpeed * DeltaSeconds) from Y
      
   b) HORIZONTAL SINE WAVE:
      - Get Game Time in Seconds
      - Add WaveSeed
      - Multiply by HorizontalFrequency
      - Calculate Sine of result
      - Multiply by HorizontalAmplitude
      - Add to BaseX
      - This becomes new X position
      
   c) Set Actor Location with new X, Y (Z stays 0)
   
   d) DESPAWN CHECK:
      - If Y < DespawnY: Destroy Actor
      - If Abs(X) > 1400: Destroy Actor

VISUAL DIAGRAM:
┌─────────────┐
│ Event Tick  │
└──────┬──────┘
       │
       ▼
┌─────────────────────────────────────────────┐
│  Get Location                                │
│  NewY = Y - (VerticalSpeed * DeltaSeconds)   │
│  NewX = BaseX + Sin(Time * Freq) * Amplitude │
│  Set Location (NewX, NewY, 0)                │
└──────────────────────────────────────────────┘

EXPECTED RESULT after Compile:
- Compile button shows GREEN checkmark
- Event Tick connected to movement and despawn logic

EXPECTED RESULT in Play mode:
- Enemies drift downward at VerticalSpeed (220 units/sec)
- Enemies oscillate horizontally in sine wave pattern
- Each enemy has different horizontal phase (due to WaveSeed)
- Enemies disappear when Y < -750 or |X| > 1400


STEP 4.4: Enemy Firing Logic
--------------------------------------------------------------------------------
1. Continue in Event Tick (after movement):

   a) Decrease FireTimer by DeltaSeconds
   
   b) Branch: if FireTimer <= 0:
      - Reset FireTimer to FireInterval
      - Call "FireBurst" function

2. CREATE "FireBurst" FUNCTION:

   a) Add function "FireBurst"
   
   b) Inside:
      - Get BulletsPerBurst
      - Calculate angle step: 360 / BulletsPerBurst (for full circle)
        OR: BurstSpread / (BulletsPerBurst - 1) (for partial arc)
      
   c) For Loop from 0 to BulletsPerBurst - 1:
      - Calculate angle: i * AngleStep
      - Convert to direction vector:
        - X = Sin(angle in radians)
        - Y = -Cos(angle in radians)  ← negative because enemies fire DOWN
      - Spawn bullet:
        - Spawn Actor from Class (BP_Bullet)
        - Get spawned bullet, call Initialize:
          - Direction = calculated direction
          - Speed = EnemyBulletSpeed
          - bIsEnemy = true
          - Lifetime = EnemyBulletLifetime

VISUAL: Radial bullet pattern (20 bullets in 360°)
                    ↑
                 ↗  |  ↖
              ↗    |    ↖
           →───────●───────←
              ↘    |    ↙
                 ↘  |  ↙
                    ↓

EXPECTED RESULT after Compile:
- Compile button shows GREEN checkmark
- "FireBurst" function appears under Functions

EXPECTED RESULT in Play mode:
- Every 0.35 seconds (FireInterval), enemy fires bullet burst
- 20 bullets spawn in a full 360° circle pattern
- Bullets travel outward from enemy position
- Different enemies fire at different times (randomized FireTimer)


STEP 4.5: Enemy Damage and Death
--------------------------------------------------------------------------------
1. CREATE "ApplyDamage" FUNCTION:

   a) Add input: DamageAmount (Integer)
   
   b) Inside:
      - Subtract DamageAmount from CurrentHealth
      - If CurrentHealth <= 0:
        - Call HandleDeath

2. CREATE "HandleDeath" FUNCTION:

   a) Inside:
      - Get reference to ScoreManager (we'll create later)
      - Call AddScore, passing ScoreValue
      - Spawn death effect (optional)
      - Destroy Actor

3. COLLISION WITH PLAYER:

   a) On the EnemyCollision component overlap event:
      - Cast Other Actor to BP_Player
      - If successful:
        - Call TakeHit(1) on player
        - Call HandleDeath() on self

EXPECTED RESULT after Compile:
- Compile button shows GREEN checkmark
- "ApplyDamage" and "HandleDeath" functions appear under Functions
- EnemyCollision has overlap event in Event Graph

EXPECTED RESULT in Play mode:
- Player bullets hitting enemy: Enemy health decreases
- After 12 hits (MaxHealth): Enemy disappears, score increases by 50
- Player colliding with enemy: Player takes 1 damage, enemy dies


================================================================================
PART 5: CREATE ENEMY SPAWNER
================================================================================

STEP 5.1: Create Spawner Blueprint
--------------------------------------------------------------------------------
1. Content Browser → Blueprints
2. Right-click → Blueprint Class → Actor
3. Name: "BP_EnemySpawner"
4. Double-click to open

5. Create Variables:
   - EnemyClass (Class Reference) - will reference BP_Enemy
   - SpawnAreaHalfWidth (Float) - Default: 900.0
   - GameDuration (Float) - Default: 300.0 (5 minutes)
   - MaxSimultaneousEnemies (Integer) - Default: 120
   - ElapsedTime (Float) - Default: 0.0
   - SpawnTimer (Float) - Default: 0.0
   - SpawningActive (Boolean) - Default: true

EXPECTED RESULT after Compile:
- Compile button shows GREEN checkmark
- Variables panel shows all 7 variables with correct types
- No components needed (spawner is invisible logic actor)


STEP 5.2: Spawn Rate Curve
--------------------------------------------------------------------------------
1. Create Variable:
   - SpawnCurve (Curve Float)
   
2. To create the curve asset:
   a) In Content Browser, right-click → Miscellaneous → Curve
   b) Select "CurveFloat"
   c) Name it "SpawnRateCurve"
   d) Double-click to open Curve Editor
   
3. In Curve Editor:
   - Right-click on the curve → Add Key
   - Create these keyframes:
     - Time: 0.0, Value: 0.4 (slow spawn at start)
     - Time: 0.5, Value: 2.0 (medium spawn halfway)
     - Time: 1.0, Value: 4.5 (fast spawn at end)
   - The X axis is normalized time (0-1)
   - The Y axis is spawns per second

4. In BP_EnemySpawner, set SpawnCurve default to this curve asset

EXPECTED RESULT in Curve Editor:
- Curve line visible starting at (0, 0.4), rising through (0.5, 2.0), ending at (1.0, 4.5)
- Smooth interpolation between keyframes

EXPECTED RESULT in Play mode:
- Game start: ~0.4 enemies spawn per second (slow)
- At 2.5 minutes: ~2 enemies spawn per second (medium)
- At 5 minutes: ~4.5 enemies spawn per second (intense)


STEP 5.3: Spawning Logic
--------------------------------------------------------------------------------
1. In Event Graph, from Event Tick:

   a) Check if SpawningActive is true
      - If false, do nothing
      
   b) Update ElapsedTime:
      - Add DeltaSeconds to ElapsedTime
      
   c) Calculate normalized time:
      - Divide ElapsedTime by GameDuration
      - Clamp between 0 and 1
      
   d) Get spawn rate from curve:
      - Get SpawnCurve
      - Call "Get Float Value" with normalized time
      - This returns spawns per second
      
   e) Update SpawnTimer:
      - Subtract DeltaSeconds from SpawnTimer
      - If SpawnTimer <= 0:
        - Reset SpawnTimer to (1.0 / SpawnsPerSecond)
        - Call SpawnWave function

2. CREATE "SpawnWave" FUNCTION:

   a) Inside:
      - Calculate burst size based on time:
        - BaseCount = 1 + (NormalizedTime * 6)
        - BurstSize = BaseCount + Random(0, 2)
        - Clamp between 1 and 12
      
   b) For Loop from 0 to BurstSize - 1:
      - Call SpawnEnemy function

3. CREATE "SpawnEnemy" FUNCTION:

   a) Inside:
      - Check: Get All Actors of Class (BP_Enemy)
        - Get array length
        - If >= MaxSimultaneousEnemies: Return (don't spawn)
      
   b) Calculate spawn position:
      - X = Random Float in Range (-SpawnAreaHalfWidth, SpawnAreaHalfWidth)
      - Y = Get this actor's Y position (top of screen)
      - Z = 0
      
   c) Spawn Actor from Class:
      - Class: EnemyClass
      - Location: calculated position
      - Rotation: (0, 0, 0)

4. CREATE "StopSpawning" FUNCTION:
   - Set SpawningActive = false

EXPECTED RESULT after Compile:
- Compile button shows GREEN checkmark
- "SpawnWave", "SpawnEnemy", "StopSpawning" functions appear under Functions

EXPECTED RESULT in Play mode:
- Enemies spawn at top of screen (Y=500) at random X positions
- Spawn rate increases over time following the curve
- Maximum 120 enemies on screen at once
- When StopSpawning called: No new enemies appear


================================================================================
PART 6: CREATE GAME DIRECTOR
================================================================================

STEP 6.1: Create Game Director Blueprint
--------------------------------------------------------------------------------
1. Content Browser → Blueprints
2. Right-click → Blueprint Class → Actor
3. Name: "BP_GameDirector"
4. Double-click to open

5. Create Variables:
   - PlayerReference (Object Reference to BP_Player)
   - SpawnerReference (Object Reference to BP_EnemySpawner)
   - GameDuration (Float) - Default: 300.0
   - ElapsedTime (Float) - Default: 0.0
   - GameActive (Boolean) - Default: true

EXPECTED RESULT after Compile:
- Compile button shows GREEN checkmark
- Variables panel shows all 5 variables with correct types
- No components needed (director is invisible logic actor)


STEP 6.2: Game Director Initialization
--------------------------------------------------------------------------------
1. From Event BeginPlay:

   a) Find player in scene:
      - Get All Actors of Class → BP_Player
      - Get first element (index 0)
      - Set PlayerReference
      
   b) Find spawner in scene:
      - Get All Actors of Class → BP_EnemySpawner
      - Get first element
      - Set SpawnerReference
      
   c) Initialize ScoreManager:
      - Get ScoreManager reference
      - Call RegisterGameStart with initial lives and duration

EXPECTED RESULT after Compile:
- Compile button shows GREEN checkmark
- BeginPlay event connected to "Get All Actors of Class" nodes

EXPECTED RESULT in Play mode:
- Game Director automatically finds Player, Spawner, and ScoreManager
- UI initializes with correct starting values (Lives: 3, Time: 05:00)


STEP 6.3: Game Director Update Logic
--------------------------------------------------------------------------------
1. From Event Tick:

   a) Check if GameActive
      - If false, skip everything
      
   b) Update elapsed time:
      - Add DeltaSeconds to ElapsedTime
      
   c) Calculate remaining time:
      - Subtract ElapsedTime from GameDuration
      - Max with 0 (don't go negative)
      
   d) Update UI timer:
      - Get ScoreManager
      - Call UpdateTimer with remaining time
      
   e) Check for victory:
      - If ElapsedTime >= GameDuration:
        - Set GameActive = false
        - Get SpawnerReference → Call StopSpawning
        - Get ScoreManager → Call HandleGameClear

2. CREATE "HandlePlayerDeath" FUNCTION:

   a) Inside:
      - Set GameActive = false
      - Get SpawnerReference → Call StopSpawning
      - Get ScoreManager → Call HandleGameOver

EXPECTED RESULT after Compile:
- Compile button shows GREEN checkmark
- "HandlePlayerDeath" function appears under Functions
- Event Tick connected to timer update and victory check

EXPECTED RESULT in Play mode:
- Timer counts down from 05:00 to 00:00
- At 00:00: "Mission Complete" appears, enemies stop spawning
- When player dies: "Game Over" appears, enemies stop spawning


================================================================================
PART 7: CREATE SCORE MANAGER / UI
================================================================================

STEP 7.1: Create UI Widget Blueprint
--------------------------------------------------------------------------------
1. Content Browser → UI folder
2. Right-click → User Interface → Widget Blueprint
3. Name: "WBP_HUD"
4. Double-click to open Widget Designer

EXPECTED RESULT: Widget Designer opens with:
- Hierarchy panel on left
- Canvas preview in center
- Details panel on right


STEP 7.2: Design HUD Layout
--------------------------------------------------------------------------------
1. In the Palette panel (left side), search for "Canvas Panel"
   - Drag Canvas Panel to the Hierarchy (if not already there)

2. Add Score Text:
   a) In Palette, search for "Text"
   b) Drag "Text" widget onto Canvas Panel in hierarchy
   c) Rename it "ScoreText" (right-click → Rename)
   d) In Details panel:
      - Under "Slot (Canvas Panel Slot)":
        - Anchors: Top-Left (click dropdown, select corner)
        - Position X: 20
        - Position Y: 20
        - Size X: 300
        - Size Y: 40
      - Under "Appearance":
        - Text: "Score: 0"
        - Font Size: 24
        - Color: White

3. Add Lives Text:
   a) Drag another "Text" widget
   b) Rename to "LivesText"
   c) Position X: 20, Y: 60
   d) Text: "Lives: 3"
   e) Same font settings as Score

4. Add Timer Text:
   a) Drag another "Text" widget
   b) Rename to "TimerText"
   c) Position X: 20, Y: 100
   d) Text: "Time: 05:00"
   e) Same font settings

5. Click "Compile" and "Save" (top buttons)

EXPECTED RESULT: Preview shows:
┌────────────────────────────────────┐
│ Score: 0                           │
│ Lives: 3                           │
│ Time: 05:00                        │
│                                    │
│                                    │
└────────────────────────────────────┘


STEP 7.3: Create Score Manager Blueprint
--------------------------------------------------------------------------------
1. Content Browser → Blueprints
2. Right-click → Blueprint Class → Actor
3. Name: "BP_ScoreManager"
4. Double-click to open

5. Create Variables:
   - Score (Integer) - Default: 0
   - CurrentLives (Integer) - Default: 3
   - HUDWidget (Object Reference to WBP_HUD)
   - HUDWidgetClass (Class Reference) - set to WBP_HUD

EXPECTED RESULT after Compile:
- Compile button shows GREEN checkmark
- Variables panel shows all 4 variables with correct types


STEP 7.4: Score Manager Initialization
--------------------------------------------------------------------------------
1. From Event BeginPlay:

   a) Create HUD Widget:
      - Right-click → "Create Widget"
      - Class: Select WBP_HUD (or use HUDWidgetClass variable)
      - Owning Player: Get Player Controller (index 0)
      
   b) Store widget reference:
      - Set HUDWidget to the created widget
      
   c) Add to viewport:
      - Right-click → "Add to Viewport"
      - Connect widget reference as target

EXPECTED RESULT after Compile:
- Compile button shows GREEN checkmark
- BeginPlay event connected to Create Widget → Add to Viewport

EXPECTED RESULT in Play mode:
- HUD appears immediately when game starts
- HUD displays in top-left corner of screen
- Text is visible and readable (white on game background)


STEP 7.5: Score Manager Functions
--------------------------------------------------------------------------------
1. CREATE "RegisterGameStart" FUNCTION:
   - Inputs: InitialLives (Integer), Duration (Float)
   - Set Score = 0
   - Set CurrentLives = InitialLives
   - Update all UI labels

2. CREATE "AddScore" FUNCTION:
   - Input: Amount (Integer)
   - Add Amount to Score
   - Update Score label in HUD:
     - Get HUDWidget
     - Cast to WBP_HUD
     - Get "ScoreText" widget
     - Set Text to "Score: " + Score

3. CREATE "SetLives" FUNCTION:
   - Input: Lives (Integer)
   - Set CurrentLives = Lives
   - Update Lives label in HUD

4. CREATE "UpdateTimer" FUNCTION:
   - Input: TimeRemaining (Float)
   - Convert to minutes:seconds format:
     - Minutes = Floor(TimeRemaining / 60)
     - Seconds = Floor(TimeRemaining mod 60)
   - Format string: "Time: MM:SS"
   - Update Timer label

5. CREATE "HandleGameOver" FUNCTION:
   - Set Timer text to "Game Over"

6. CREATE "HandleGameClear" FUNCTION:
   - Set Timer text to "Mission Complete"

EXPECTED RESULT after Compile:
- Compile button shows GREEN checkmark
- All 6 functions appear under Functions panel

EXPECTED RESULT in Play mode:
- Score updates instantly when enemies are killed (+50 each)
- Lives display updates when player is hit
- Timer counts down in MM:SS format
- "Game Over" or "Mission Complete" replaces timer at game end


================================================================================
PART 8: CREATE GAME MODE AND LEVEL
================================================================================

STEP 8.1: Create Custom Game Mode
--------------------------------------------------------------------------------
1. Content Browser → Blueprints
2. Right-click → Blueprint Class
3. In popup, expand "All Classes"
4. Search for "Game Mode Base"
5. Select "Game Mode Base" and click Select
6. Name: "BP_BulletHellGameMode"
7. Double-click to open

8. In the Details panel (with BP_BulletHellGameMode open):
   - Find "Classes" section
   - Default Pawn Class: Select "BP_Player"
   - Player Controller Class: Keep default

EXPECTED RESULT after Compile:
- Compile button shows GREEN checkmark
- Details panel shows "Default Pawn Class" set to BP_Player


STEP 8.2: Configure Project to Use Game Mode
--------------------------------------------------------------------------------
1. Go to Edit → Project Settings
2. In left sidebar, click "Maps & Modes"
3. Under "Default Modes":
   - Default GameMode: Select BP_BulletHellGameMode
4. Close Project Settings

EXPECTED RESULT:
- Project Settings shows BP_BulletHellGameMode as Default GameMode
- This means the game will automatically spawn BP_Player when Play is pressed


STEP 8.3: Create Game Level
--------------------------------------------------------------------------------
1. File → New Level
2. Select "Empty Level"
3. File → Save Current Level As
4. Navigate to Content folder
5. Name: "BulletHellLevel"
6. Click Save

EXPECTED RESULT:
- New level file "BulletHellLevel" appears in Content folder
- Level is completely empty (black viewport)
- Outliner shows only default actors (if any)


STEP 8.4: Set Up Level Components
--------------------------------------------------------------------------------
1. In the level (main viewport), we need to add game actors:

2. ADD CAMERA:
   a) In Place Actors panel (left side, or Window → Place Actors)
   b) Search for "Camera Actor"
   c) Drag into viewport
   d) Position camera:
      - In Details panel, under Transform:
      - Location: X=0, Y=0, Z=1000
      - Rotation: X=-90, Y=0, Z=0 (looking down)
   e) Set as default camera:
      - In Details panel, find "Auto Activate for Player"
      - Check the box, set Player Index to 0
   
   FOR ORTHOGRAPHIC VIEW:
   - Click on Camera component
   - In Details, set "Projection Mode" to "Orthographic"
   - Set "Ortho Width" to 1920 (or your screen width)

3. ADD PLAYER:
   a) From Content Browser, drag "BP_Player" into level
   b) Position: X=0, Y=-300, Z=0 (bottom center)

4. ADD ENEMY SPAWNER:
   a) Drag "BP_EnemySpawner" into level
   b) Position: X=0, Y=500, Z=0 (top of screen)
   c) In Details panel, set EnemyClass to "BP_Enemy"

5. ADD GAME DIRECTOR:
   a) Drag "BP_GameDirector" into level
   b) Position doesn't matter (it's invisible)

6. ADD SCORE MANAGER:
   a) Drag "BP_ScoreManager" into level
   b) Position doesn't matter

7. Save the level (Ctrl+S)

EXPECTED RESULT in Level Viewport:
- Camera actor visible at top of scene (Z=1000)
- BP_Player visible at bottom center (Y=-300)
- BP_EnemySpawner visible at top (Y=500)
- BP_GameDirector and BP_ScoreManager in Outliner (invisible actors)

EXPECTED RESULT in Outliner:
- CameraActor
- BP_Player
- BP_EnemySpawner  
- BP_GameDirector
- BP_ScoreManager


STEP 8.5: Set Default Level
--------------------------------------------------------------------------------
1. Edit → Project Settings
2. Maps & Modes
3. Under "Default Maps":
   - Editor Startup Map: Select BulletHellLevel
   - Game Default Map: Select BulletHellLevel

EXPECTED RESULT:
- Project Settings shows BulletHellLevel as both startup and default map
- Launching the game (standalone or in editor) loads this level automatically


================================================================================
PART 9: FINAL SETUP AND TESTING
================================================================================

STEP 9.1: Assign Blueprint References
--------------------------------------------------------------------------------
1. Open BP_Player:
   - In Details panel (with blueprint open)
   - Set BulletClass: BP_Bullet

2. Open BP_EnemySpawner:
   - Set EnemyClass: BP_Enemy

3. Open BP_Enemy:
   - Set BulletClass: BP_Bullet

4. Compile and Save all blueprints

EXPECTED RESULT after Compile (all blueprints):
- All blueprints compile with GREEN checkmark
- No "None" or missing references in variable defaults
- BP_Player.BulletClass → BP_Bullet
- BP_Enemy.BulletClass → BP_Bullet  
- BP_EnemySpawner.EnemyClass → BP_Enemy

EXPECTED RESULT in Play mode:
- Player can shoot bullets (BP_Bullet spawns)
- Enemies spawn and shoot bullets
- All collision/damage systems functional


STEP 9.2: Create Final Visuals (Replace Placeholder)
--------------------------------------------------------------------------------
Now replace the temporary cube visuals with proper colored materials:

1. REMOVE TEMPORARY COMPONENTS:
   a) Open BP_Player blueprint
   b) In Components panel, select "TempVisual" (the cube added in Step 2.2)
   c) Press Delete to remove it
   d) Select "PlayerCamera" and delete it (the level camera from Step 8.4 will be used)
   e) Repeat for BP_Bullet and BP_Enemy (delete their TempVisual cubes)

2. Content Browser → Materials folder

3. PLAYER MATERIAL:
   a) Right-click → Material
   b) Name: "M_Player"
   c) Double-click to open Material Editor
   d) Create Vector3 node (hold 3, click)
   e) Set to blue color (0, 0.5, 1)
   f) Connect to Base Color
   g) Save and Close

4. BULLET MATERIAL:
   a) Create "M_PlayerBullet" - Yellow (1, 1, 0)
   b) Create "M_EnemyBullet" - Red (1, 0, 0)

5. ENEMY MATERIAL:
   a) Create "M_Enemy" - Magenta (1, 0, 1)

6. Apply materials to sprite components in each Blueprint
   (Or use Sprite assets if you have 2D images)

EXPECTED RESULT in Play mode:
- Player visible as blue shape
- Player bullets visible as yellow shapes
- Enemy bullets visible as red shapes
- Enemies visible as magenta shapes
- All game elements distinguishable by color


STEP 9.3: Add Background (Optional)
--------------------------------------------------------------------------------
1. In level, add a Plane mesh:
   - Place Actors → Basic → Plane
   - Scale: X=20, Y=30, Z=1
   - Position: X=0, Y=0, Z=-100 (behind everything)

2. Create dark space material:
   - M_Background - Dark blue/black

EXPECTED RESULT in Play mode:
- Dark background visible behind all game elements
- Game elements (player, enemies, bullets) clearly visible against background
- Background doesn't interfere with gameplay (Z=-100, behind everything)


STEP 9.4: Test the Game
--------------------------------------------------------------------------------
1. Click "Play" button (green arrow in main toolbar)
   OR press Alt+P

2. TEST CHECKLIST:
   □ Player moves with WASD or Arrow keys
   □ Player stays within screen bounds
   □ Player shoots with Z key or Left Mouse
   □ Bullets travel upward
   □ Enemies spawn at top of screen
   □ Enemies move down with wavy motion
   □ Enemies shoot radial bullet patterns
   □ Player bullets damage enemies
   □ Enemy bullets damage player
   □ Score increases when enemies die
   □ Lives decrease when player is hit
   □ Timer counts down from 5:00
   □ Game shows "Game Over" when lives = 0
   □ Game shows "Mission Complete" after 5 minutes
   □ Special ability (X key) clears screen

3. To stop playing: Press ESC or click "Stop" button

EXPECTED RESULT - Complete Game Test:
- All checklist items above should pass
- Frame rate stable (60+ FPS recommended)
- No crashes or Blueprint errors in Output Log
- Game is playable from start to victory/defeat


STEP 9.5: Build Standalone Game
--------------------------------------------------------------------------------
1. File → Package Project → Windows (or your platform)
2. Select output folder
3. Wait for build to complete
4. Navigate to output folder → WindowsNoEditor → [ProjectName].exe
5. Run the executable to play standalone

EXPECTED RESULT:
- Build completes without errors (check Output Log)
- Executable file created in output folder
- Running .exe launches the game in fullscreen
- Game plays identically to editor Play mode
- Can close with Alt+F4 or in-game quit (if implemented)


================================================================================
APPENDIX A: COMPLETE VARIABLE REFERENCE
================================================================================

BP_PLAYER Variables:
┌─────────────────────┬───────────────┬───────────────────────────────┐
│ Variable Name       │ Type          │ Default Value                 │
├─────────────────────┼───────────────┼───────────────────────────────┤
│ MoveSpeed           │ Float         │ 750.0                         │
│ BoundsMin           │ Vector 2D     │ (-850, -450)                  │
│ BoundsMax           │ Vector 2D     │ (850, 450)                    │
│ FireInterval        │ Float         │ 0.08                          │
│ FireTimer           │ Float         │ 0.0                           │
│ BulletSpeed         │ Float         │ 2200.0                        │
│ MaxLives            │ Integer       │ 3                             │
│ CurrentLives        │ Integer       │ 3                             │
│ VolleySize          │ Integer       │ 3                             │
│ VolleySpread        │ Float         │ 12.0                          │
│ SpecialUsed         │ Boolean       │ false                         │
│ BulletClass         │ Class Ref     │ BP_Bullet                     │
└─────────────────────┴───────────────┴───────────────────────────────┘

BP_BULLET Variables:
┌─────────────────────┬───────────────┬───────────────────────────────┐
│ TravelDirection     │ Vector        │ (0, 1, 0)                     │
│ TravelSpeed         │ Float         │ 1200.0                        │
│ RemainingLifetime   │ Float         │ 4.0                           │
│ IsEnemyProjectile   │ Boolean       │ false                         │
│ Damage              │ Integer       │ 1                             │
└─────────────────────┴───────────────┴───────────────────────────────┘

BP_ENEMY Variables:
┌─────────────────────┬───────────────┬───────────────────────────────┐
│ MaxHealth           │ Integer       │ 12                            │
│ CurrentHealth       │ Integer       │ 12                            │
│ ScoreValue          │ Integer       │ 50                            │
│ VerticalSpeed       │ Float         │ 220.0                         │
│ HorizontalAmplitude │ Float         │ 250.0                         │
│ HorizontalFrequency │ Float         │ 1.8                           │
│ DespawnY            │ Float         │ -750.0                        │
│ FireInterval        │ Float         │ 0.35                          │
│ BulletsPerBurst     │ Integer       │ 20                            │
│ BurstSpread         │ Float         │ 360.0                         │
│ EnemyBulletSpeed    │ Float         │ 1000.0                        │
│ EnemyBulletLifetime │ Float         │ 6.0                           │
│ BaseX               │ Float         │ 0.0                           │
│ WaveSeed            │ Float         │ 0.0                           │
│ FireTimer           │ Float         │ 0.0                           │
│ BulletClass         │ Class Ref     │ BP_Bullet                     │
└─────────────────────┴───────────────┴───────────────────────────────┘

BP_ENEMYSPAWNER Variables:
┌─────────────────────┬───────────────┬───────────────────────────────┐
│ EnemyClass          │ Class Ref     │ BP_Enemy                      │
│ SpawnAreaHalfWidth  │ Float         │ 900.0                         │
│ GameDuration        │ Float         │ 300.0                         │
│ MaxSimultaneousEnemies│ Integer     │ 120                           │
│ ElapsedTime         │ Float         │ 0.0                           │
│ SpawnTimer          │ Float         │ 0.0                           │
│ SpawningActive      │ Boolean       │ true                          │
│ SpawnCurve          │ Curve Float   │ SpawnRateCurve asset          │
└─────────────────────┴───────────────┴───────────────────────────────┘


================================================================================
APPENDIX B: TROUBLESHOOTING
================================================================================

PROBLEM: Player doesn't move
SOLUTIONS:
1. Verify IMC_Default Input Mapping Context is added in BeginPlay
2. Check that IA_Move Input Action exists and has correct key bindings
3. Ensure "Possess" is called on player pawn (automatic with GameMode)
4. Verify MoveSpeed > 0
5. Check if blueprint has errors (Compile button should be green checkmark)
6. Make sure Enhanced Input plugin is enabled (Edit → Plugins → Enhanced Input)

PROBLEM: Bullets don't spawn
SOLUTIONS:
1. Check BulletClass variable is set to BP_Bullet
2. Verify SpawnActor node has valid class
3. Check that fire logic is connected to execution flow

PROBLEM: No collisions detected
SOLUTIONS:
1. Verify collision components have "Generate Overlap Events" checked
2. Check collision channels are set correctly
3. Ensure "Collision Enabled" is set to "Query Only" or "Query and Physics"

PROBLEM: UI doesn't appear
SOLUTIONS:
1. Check HUD widget is created and added to viewport
2. Verify ScoreManager is in the level
3. Check widget blueprint compiles without errors

PROBLEM: Enemies don't spawn
SOLUTIONS:
1. Check EnemyClass is set in Spawner
2. Verify SpawningActive is true
3. Check spawn position is within camera view

PROBLEM: Game runs too fast/slow
SOLUTIONS:
1. All movement should multiply by DeltaSeconds
2. Check speed values (may need adjustment for Unreal scale)
3. Unreal uses centimeters; multiply Unity values by ~100


================================================================================
APPENDIX C: UNITY TO UNREAL CONVERSION NOTES
================================================================================

SCALE CONVERSION:
- Unity units (1 = 1 meter) → Unreal units (1 = 1 centimeter)
- Multiply all Unity position/speed values by 100
- Example: Unity speed 7.5 → Unreal speed 750

COORDINATE SYSTEM:
- Unity: Y = up, Z = forward
- Unreal: Z = up, X = forward
- For 2D top-down: Both use X for horizontal, but Y/Z swap for vertical

INPUT:
- Unity: Input.GetAxisRaw("Horizontal")
- Unreal (Enhanced Input): 
  1. Create Input Action (IA_Move) with Axis2D type
  2. Create Input Mapping Context with key bindings
  3. Add Mapping Context in BeginPlay
  4. Use "Get Action Value" node to read input

INSTANTIATE:
- Unity: Instantiate(prefab, position, rotation)
- Unreal: Spawn Actor from Class (class, transform)

DESTROY:
- Unity: Destroy(gameObject)
- Unreal: Destroy Actor

DELTATIME:
- Unity: Time.deltaTime
- Unreal: Get World Delta Seconds

FIND OBJECTS:
- Unity: FindObjectOfType<T>()
- Unreal: Get All Actors of Class → Get first element

SINGLETON PATTERN:
- Unity: static Instance property
- Unreal: Use Game Instance or subsystem, or Get All Actors


================================================================================
END OF TUTORIAL
================================================================================

This tutorial creates a complete bullet-hell game matching the Unity magisterka_1 
implementation with:
- Player with 3 lives, WASD movement, Z/mouse shooting
- Volley shooting (3 bullets in spread pattern)
- Screen-clear special ability (X key, one use)
- Enemies with sine-wave movement
- Radial bullet patterns (20 bullets per burst)
- Progressive difficulty (spawn rate increases over 5 minutes)
- Score, lives, and timer UI
- Victory after 5 minutes survival
- Game over when lives reach 0
